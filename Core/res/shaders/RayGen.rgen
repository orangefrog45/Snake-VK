#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

struct RayPayload {
  vec3 colour;
  vec3 normal;
  float distance;
  float roughness;
  uint mat_flags;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

struct ShadowRayPayload {
  bool hit;
};

layout(location = 1) rayPayloadEXT ShadowRayPayload shadow_payload;

layout(set = 1, binding = 0) uniform accelerationStructureEXT as;

layout(set = 1, binding = 1, rgba8) uniform writeonly image2D img_output;

layout(set = 1, binding = 9) uniform sampler2D sampler_gbuffer_albedo;
layout(set = 1, binding = 10) uniform sampler2D sampler_gbuffer_normals;
layout(set = 1, binding = 11) uniform sampler2D sampler_gbuffer_depth;
layout(set = 1, binding = 12) uniform sampler2D sampler_gbuffer_rma;
layout(set = 1, binding = 13) uniform usampler2D sampler_gbuffer_mat_flags;

#define LIGHT_BUFFER_DESCRIPTOR_SET_BINDING_OVERRIDE
#define LIGHT_BUFFER_DESCRIPTOR_SET_IDX 1
#define LIGHT_BUFFER_DESCRIPTOR_BINDING 8
#include "LightBuffers.glsl"

#define TRANSFORM_BUFFER_DESCRIPTOR_SET_IDX 1
#define TRANSFORM_BUFFER_DESCRIPTOR_BINDING 14
#include "Transforms.glsl"

#include "CommonUBO.glsl"
#include "Util.glsl"

#define TEX_MAT_DESCRIPTOR_SET_IDX 2
#include "TexMatBuffers.glsl"


vec3 BouncePerfectReflections(vec3 ro, vec3 rd) {
  vec3 colour_sum = vec3(0);
  for (uint bounce = 0; bounce < 8; bounce++) {

    traceRayEXT(
      as,
      gl_RayFlagsOpaqueEXT,
      0xff,
      0,
      0,
      0,
      ro,
      0.001,
      rd, 
      1000,
      0
    );

    colour_sum += payload.colour;
    if (payload.distance < 0.f) {
      break;
    }

    ro = ro + rd * payload.distance;
    rd = normalize(reflect(rd, payload.normal));
  } 

  return colour_sum;
}

void CreateCoordinateSystem(in vec3 n, out vec3 nt, out vec3 nb) {
  if (abs(n.x) > abs(n.y))
    nt = vec3(n.z, 0, -n.x) / length(n.xz);
  else
    nt = vec3(0, -n.z, n.y) / length(n.yz);

    nb = cross(n, nt);
}

vec3 UniformSampleHemisphere(float r1, float r2) {
  float sin_theta = sqrt(1 - r1 * r1);
  float phi = 2 * PI * r2;
  return vec3(sin_theta * cos(phi), r1, sin_theta * sin(phi));
}

float r(vec2 st) {
  return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec3 BounceDiffuse(vec3 ro, vec3 normal, vec3 reflected_dir, vec3 albedo, float roughness) {
  vec3 colour_sum = vec3(0);

  vec3 nt;
  vec3 nb;
  CreateCoordinateSystem(normal, nt, nb);

  vec3 nt_inner;
  vec3 nb_inner;
  vec3 n_inner;

  float l2_ro = dot(ro, ro);

  for (uint ray_idx = 0; ray_idx < 8; ray_idx++) {
    vec3 rnd = UniformSampleHemisphere(random(ray_idx+l2_ro+ro.x+common_ubo.frame_idx), random(ray_idx-l2_ro+ro.y+common_ubo.frame_idx));
    vec3 rd = vec3(
      rnd.x * nb.x + rnd.y * normal.x + rnd.z * nt.x,
      rnd.x * nb.y + rnd.y * normal.y + rnd.z * nt.y,
      rnd.x * nb.z + rnd.y * normal.z + rnd.z * nt.z
    );

    traceRayEXT(
      as,
      gl_RayFlagsOpaqueEXT,
      0xff,
      0,
      0,
      0,
      ro,
      0.01,
      rd, 
      1000,
      0
    );

    colour_sum += albedo * payload.colour * max(cos(dot(rd, normal)), 0.0) / 8.0;
    if (payload.distance < 0.f || bool(payload.mat_flags & MAT_FLAG_EMISSIVE)) {
      continue;
    }

    vec3 new_pos = ro + rd * payload.distance;
    n_inner = payload.normal;
    CreateCoordinateSystem(n_inner, nt_inner, nb_inner);

    for (uint bounce_idx = 0; bounce_idx < 2; bounce_idx++) {
      rd = UniformSampleHemisphere(random(bounce_idx+l2_ro+new_pos.x+common_ubo.frame_idx), random(bounce_idx-l2_ro+new_pos.y+common_ubo.frame_idx));
      rd = vec3(
      rd.x * nb_inner.x + rd.y * n_inner.x + rd.z * nt_inner.x,
      rd.x * nb_inner.y + rd.y * n_inner.y + rd.z * nt_inner.y,
      rd.x * nb_inner.z + rd.y * n_inner.z + rd.z * nt_inner.z
      );

      traceRayEXT(
        as,
        gl_RayFlagsOpaqueEXT,
        0xff,
        0,
        0,
        0,
        new_pos,
        0.01,
        rd, 
        1000,
        0
      );
      colour_sum += albedo * payload.colour * 0.25 * max(cos(dot(rd, n_inner)), 0.0);
    }
  }

  return colour_sum / (2 * PI);
}

float ShadowTest(vec3 ro, vec3 rd, float max_dist) {
  // Set initially to true, miss shader sets to false
  shadow_payload.hit = true;

  uint flags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
  traceRayEXT(
    as,
    flags,
    0xff,
    0,
    0,
    1,
    ro,
    0.001,
    rd, 
    max_dist,
    1
  );

  return 1.0 - float(shadow_payload.hit);
}


void main() {
  vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);

  vec3 albedo = texelFetch(sampler_gbuffer_albedo, ivec2(gl_LaunchIDEXT), 0).rgb;

  const vec3 rma = texelFetch(sampler_gbuffer_rma, ivec2(gl_LaunchIDEXT), 0).rgb;
  const uint mat_flags = texelFetch(sampler_gbuffer_mat_flags, ivec2(gl_LaunchIDEXT), 0).r;


  if (bool(mat_flags & MAT_FLAG_EMISSIVE)) {
    imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(albedo, 1.0));
    return;
  } 

  vec3 normal = texelFetch(sampler_gbuffer_normals, ivec2(gl_LaunchIDEXT), 0).rgb;
  vec3 ro = WorldPosFromDepth(texelFetch(sampler_gbuffer_depth, ivec2(gl_LaunchIDEXT), 0).r, uv);

  vec3 v = normalize(common_ubo.cam_pos.xyz - ro);
	vec3 r = reflect(-v, normal);
	float n_dot_v = max(dot(normal, v), 0.0);

  vec3 f0 = vec3(0.04); // TODO: Support different values for more metallic objects
  f0 = mix(f0, albedo, rma.g);

  vec3 biased_pos = ro + normal * 0.1;

  vec3 light = CalcDirectionalLight(v, f0, normal, rma.r, rma.g, albedo) * ShadowTest(biased_pos, ssbo_light_data.dir_light.dir.xyz, 1000);
  if (ssbo_light_data.num_pointlights > 0) {
    light += CalcPointlight(ssbo_light_data.pointlights[0], v, f0, ro, normal, rma.r, rma.g, albedo.rgb) * ShadowTest(biased_pos, ssbo_light_data.pointlights[0].pos.xyz - biased_pos, 10000);
  }

  vec3 colour_sum = light;
  colour_sum += BounceDiffuse(biased_pos, normal, r, albedo, rma.r);

  imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(colour_sum, 1.0));
}