#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

struct RayPayload {
  vec3 colour;
  vec3 normal;
  float distance;
  float roughness;
  uint mat_flags;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

struct ShadowRayPayload {
  bool hit;
};

layout(location = 1) rayPayloadEXT ShadowRayPayload shadow_payload;

layout(set = 1, binding = 0) uniform accelerationStructureEXT as;
layout(set = 1, binding = 2, scalar) readonly buffer VertexPositionBuf { vec3 p[]; } vert_positions;
layout(set = 1, binding = 3, scalar) readonly buffer IndexBuf { ivec3 i[]; } indices;
layout(set = 1, binding = 4, scalar) readonly buffer VertexNormalBuf { vec3 n[]; } vert_normals;
layout(set = 1, binding = 5, scalar) readonly buffer VertexTexCoordBuf { vec2 t[]; } vert_tex_coords;
layout(set = 1, binding = 6, scalar) readonly buffer VertexTangentBuf { vec3 t[]; } vert_tangents;

layout(set = 1, binding = 1, rgba8) uniform writeonly image2D img_output;

layout(set = 1, binding = 9) uniform sampler2D sampler_gbuffer_albedo;
layout(set = 1, binding = 10) uniform sampler2D sampler_gbuffer_normals;
layout(set = 1, binding = 11) uniform sampler2D sampler_gbuffer_depth;
layout(set = 1, binding = 12) uniform sampler2D sampler_gbuffer_rma;
layout(set = 1, binding = 13) uniform usampler2D sampler_gbuffer_mat_flags;
//layout(set = 1, binding = 16, rgba16) uniform image2D img_reservoirs;

#define LIGHT_BUFFER_DESCRIPTOR_SET_BINDING_OVERRIDE
#define LIGHT_BUFFER_DESCRIPTOR_SET_IDX 1
#define LIGHT_BUFFER_DESCRIPTOR_BINDING 8
#include "LightBuffers.glsl"

#define TRANSFORM_BUFFER_DESCRIPTOR_SET_IDX 1
#define TRANSFORM_BUFFER_DESCRIPTOR_BINDING 14
#include "Transforms.glsl"

#define RAYTRACING_INSTANCE_BUFFER_DESCRIPTOR_SET_IDX 1
#define RAYTRACING_INSTANCE_BUFFER_DESCRIPTOR_BINDING 7
#define RAYTRACING_EMISSIVE_BUFFER_DESCRIPTOR_BINDING 16
#include "RaytracingInstances.glsl"

#include "CommonUBO.glsl"
#include "Util.glsl"

#define TEX_MAT_DESCRIPTOR_SET_IDX 2
#include "TexMatBuffers.glsl"

#define LIGHT_RIS_ITERS 32u
#define INVALID_RESERVOIR_IDX ~0u

struct PointlightReservoir {
  float w_sum;
  uint current_light_idx;
};

struct EmissivePointReservoir {
  float w_sum;
  uint emissive_object_instance_idx;
  vec3 point;
  vec3 radiance;
};

float ShadowTest(vec3 ro, vec3 rd, float max_dist) {
  // Set initially to true, miss shader sets to false
  shadow_payload.hit = true;

  uint flags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
  traceRayEXT(
    as,
    flags,
    0xff,
    0,
    0,
    1,
    ro,
    0.001,
    rd, 
    max_dist,
    1
  );

  return 1.0 - float(shadow_payload.hit);
}

PointlightReservoir UpdatePointlightReservoir(vec3 v, vec3 f0, vec3 world_pos, vec3 n, float roughness, float metallic, vec3 albedo, vec3 biased_pos, uint N) {
  const ivec2 coord = ivec2(gl_LaunchIDEXT.xy);
  PointlightReservoir reservoir;
  reservoir.current_light_idx = INVALID_RESERVOIR_IDX;
  reservoir.w_sum = 0.0;

  for (uint i = 0u; i < LIGHT_RIS_ITERS; i++) {
    const uint rnd_idx = uint(gold_noise(vec2(coord), fract(common_ubo.delta_time+sin(N*937.281739)) + i / float(LIGHT_RIS_ITERS)) * float(ssbo_light_data.num_pointlights));

    float weight = length(CalcPointlight(ssbo_light_data.pointlights[rnd_idx], v, f0, world_pos, n, roughness, metallic, albedo));
    weight /= (1.0 / float(ssbo_light_data.num_pointlights));
    reservoir.w_sum += weight;

    const float rnd = gold_noise(vec2(coord.yx), fract(common_ubo.delta_time*0.1+sin(N*383.48273)) - i / float(LIGHT_RIS_ITERS));
    if (rnd < weight / reservoir.w_sum) {
      reservoir.current_light_idx = rnd_idx;
    }
  }

  //imageStore(img_reservoirs, coord, vec4(reservoir.w_sum, reservoir.current_weight, uintBitsToFloat(reservoir.current_light_idx), 1.0));

  return reservoir;
}

EmissivePointReservoir UpdateEmissivePointReservoir(vec3 surface_pos, vec3 v, vec3 f0, vec3 n, float roughness, float metallic, vec3 albedo, vec3 biased_pos, uint N) {
  const ivec2 coord = ivec2(gl_LaunchIDEXT.xy);
  
  EmissivePointReservoir reservoir;
  reservoir.w_sum = 0.0;
  reservoir.emissive_object_instance_idx = INVALID_RESERVOIR_IDX;

  for (uint i = 0u; i < LIGHT_RIS_ITERS; i++) {
    uint rnd_emissive_idx = uint(gold_noise(vec2(coord), abs(fract(surface_pos.z+common_ubo.time_elapsed*0.001+sin(N*633.267) + i / float(LIGHT_RIS_ITERS))))
     * float(rt_emissive_instance_indices.num_emissive_instances));

    // Pick a random emissive object
    InstanceData instance = rt_instances.i[rt_emissive_instance_indices.i[rnd_emissive_idx]];

    const uint rnd_triangle_idx = uint(gold_noise(vec2(coord), abs(fract(surface_pos.x+common_ubo.time_elapsed*0.001+sin(N*237.379) + i / float(LIGHT_RIS_ITERS))))
     * float(instance.num_mesh_indices / 3));

    // Pick random triangle on the emissive object
    ivec3 ti = indices.i[rnd_triangle_idx + instance.mesh_buffer_index_offset / 3] + ivec3(instance.mesh_buffer_vertex_offset);

    // Create random barycentric coordinate to sample inside triangle
    vec3 bary = vec3(random(sin(i+N+coord.x*293.28) + common_ubo.time_elapsed*0.001+i), random(sin(i*0.8583+N+coord.y*983.3399) + ti.y + common_ubo.time_elapsed*0.001+i), 0);
    if (bary.x + bary.y >= 1) {
      bary.x = 1 - bary.x;
      bary.y = 1 - bary.y;
    }
    bary.z = 1.0 - bary.x - bary.y;

    vec3 p = bary.x * vert_positions.p[ti.x] + bary.y * vert_positions.p[ti.y] + bary.z * vert_positions.p[ti.z];
    vec3 point_normal = bary.x * vert_normals.n[ti.x] + bary.y * vert_normals.n[ti.y] + bary.z * vert_normals.n[ti.z];

    p = vec4(transforms.m[instance.transform_idx] * vec4(p, 1.0)).xyz;
    point_normal = normalize(transpose(inverse(mat3(transforms.m[instance.transform_idx]))) * point_normal);

    float triangle_area = 0.5 * length(cross(vert_positions.p[ti.y] - vert_positions.p[ti.x], vert_positions.p[ti.y] - vert_positions.p[ti.z]));
    vec3 emissive = material_ubo.materials[instance.material_idx].albedo.xyz;
    vec3 brdf = CookTorranceBRDF(p, surface_pos, v, f0, n, roughness, metallic);

    float pdf = 1.0 / (rt_emissive_instance_indices.num_emissive_instances * (instance.num_mesh_indices / 3) * triangle_area);
    float weight = length(emissive*albedo*brdf) / abs(dot(surface_pos - p, surface_pos - p));
    weight /= pdf;

    reservoir.w_sum += weight;
    float rnd = uint(gold_noise(vec2(coord), abs(fract(p.z+p.y+p.z+common_ubo.time_elapsed*0.001+sin(N*237.379) + i / float(LIGHT_RIS_ITERS)))));
    rnd = random(dot(p.xyz, p.yzx));
    if (rnd < weight / max(reservoir.w_sum, 0.000001)) {
        reservoir.emissive_object_instance_idx = rnd_emissive_idx;
        reservoir.point = p;
        reservoir.radiance = albedo*brdf*emissive / abs(dot(surface_pos - p, surface_pos - p));
    }
  }

  return reservoir;
}

void CreateCoordinateSystem(in vec3 n, out vec3 nt, out vec3 nb) {
  if (abs(n.x) > abs(n.y))
    nt = vec3(n.z, 0, -n.x) / length(n.xz);
  else
    nt = vec3(0, -n.z, n.y) / length(n.yz);

    nb = cross(n, nt);
}

vec3 UniformSampleHemisphere(float r1, float r2) {
  float sin_theta = sqrt(1 - r1 * r1);
  float phi = 2 * PI * r2;
  return vec3(sin_theta * cos(phi), r1, sin_theta * sin(phi));
}


vec3 BounceDiffuse(vec3 ro, vec3 normal, vec3 reflected_dir, vec3 albedo, float roughness) {
  return vec3(0);
  vec3 colour_sum = vec3(0);

  vec3 nt;
  vec3 nb;
  CreateCoordinateSystem(normal, nt, nb);

  vec3 nt_inner;
  vec3 nb_inner;
  vec3 n_inner;

  float l2_ro = dot(ro, ro);

  float seed = fract(l2_ro+ro.x+ro.y+ro.z+common_ubo.time_elapsed+common_ubo.delta_time);
  vec2 xy = gl_LaunchIDEXT.xy;
  xy += fract(vec2(sin(xy.x*1038.283726 + xy.y*common_ubo.delta_time), cos(xy.x*common_ubo.time_elapsed+xy.y*9278.33337)));
  for (uint ray_idx = 0; ray_idx < 8; ray_idx++) {
    seed = fract(seed + ray_idx/8.0);
    vec3 rnd = UniformSampleHemisphere(gold_noise(xy, fract(seed+ray_idx/8.0)), gold_noise(xy, fract(seed+ray_idx/8.0)+0.1));
    vec3 rd = vec3(
      rnd.x * nb.x + rnd.y * normal.x + rnd.z * nt.x,
      rnd.x * nb.y + rnd.y * normal.y + rnd.z * nt.y,
      rnd.x * nb.z + rnd.y * normal.z + rnd.z * nt.z
    );

    traceRayEXT(
      as,
      gl_RayFlagsOpaqueEXT,
      0xff,
      0,
      0,
      0,
      ro,
      0.01,
      rd, 
      1000,
      0
    );

    colour_sum += albedo * payload.colour * max(cos(dot(rd, normal)), 0.0) / 8.0;
    if (payload.distance < 0.f || bool(payload.mat_flags & MAT_FLAG_EMISSIVE)) {
      continue;
    }

    vec3 new_pos = ro + rd * payload.distance;
    n_inner = payload.normal;
    CreateCoordinateSystem(n_inner, nt_inner, nb_inner);

    for (uint bounce_idx = 0; bounce_idx < 2; bounce_idx++) {
      rd = UniformSampleHemisphere(gold_noise(xy, fract(seed+bounce_idx*0.5+0.2)), gold_noise(xy, fract(seed+bounce_idx*0.5+0.3)));
      rd = vec3(
      rd.x * nb_inner.x + rd.y * n_inner.x + rd.z * nt_inner.x,
      rd.x * nb_inner.y + rd.y * n_inner.y + rd.z * nt_inner.y,
      rd.x * nb_inner.z + rd.y * n_inner.z + rd.z * nt_inner.z
      );

      traceRayEXT(
        as,
        gl_RayFlagsOpaqueEXT,
        0xff,
        0,
        0,
        0,
        new_pos,
        0.01,
        rd, 
        1000,
        0
      );
      colour_sum += albedo * payload.colour * 0.25 * max(cos(dot(rd, n_inner)), 0.0) / 8.0;
    }
  }

  return colour_sum * (2 * PI);
}


void main() {
  vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);

  vec3 albedo = texelFetch(sampler_gbuffer_albedo, ivec2(gl_LaunchIDEXT), 0).rgb;

  const vec3 rma = texelFetch(sampler_gbuffer_rma, ivec2(gl_LaunchIDEXT), 0).rgb;
  const uint mat_flags = texelFetch(sampler_gbuffer_mat_flags, ivec2(gl_LaunchIDEXT), 0).r;


  if (bool(mat_flags & MAT_FLAG_EMISSIVE)) {
    imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(albedo, 1.0));
    return;
  } 

  vec3 normal = texelFetch(sampler_gbuffer_normals, ivec2(gl_LaunchIDEXT), 0).rgb;
  vec3 ro = WorldPosFromDepth(texelFetch(sampler_gbuffer_depth, ivec2(gl_LaunchIDEXT), 0).r, uv);

  vec3 v = normalize(common_ubo.cam_pos.xyz - ro);
	vec3 r = reflect(-v, normal);
	float n_dot_v = max(dot(normal, v), 0.0);

  vec3 f0 = vec3(0.04); // TODO: Support different values for more metallic objects
  f0 = mix(f0, albedo, rma.g);

  vec3 biased_pos = ro + normal * 0.1;

  vec3 light = CalcDirectionalLight(v, f0, normal, rma.r, rma.g, albedo) * ShadowTest(biased_pos, ssbo_light_data.dir_light.dir.xyz, 1000);

  if (ssbo_light_data.num_pointlights > 0) {
    const uint N = 4;
    for (uint i = 0u; i < N; i++) {
      PointlightReservoir reservoir = UpdatePointlightReservoir(v, f0, ro, normal, rma.r, rma.g, albedo, biased_pos, i);
      if (reservoir.current_light_idx == INVALID_RESERVOIR_IDX)
        continue;

      float light_dist = length(ssbo_light_data.pointlights[reservoir.current_light_idx].pos.xyz - biased_pos);
      vec3 pointlight_radiance = CalcPointlight(ssbo_light_data.pointlights[reservoir.current_light_idx], v, f0, ro, normal, rma.r, rma.g, albedo.rgb) * 
        ShadowTest(biased_pos, (ssbo_light_data.pointlights[reservoir.current_light_idx].pos.xyz - biased_pos) / light_dist, light_dist);

      float p_hat = length(pointlight_radiance);

      pointlight_radiance *= p_hat > 0.001 ? reservoir.w_sum / p_hat / float(LIGHT_RIS_ITERS) : 0.0;
      light += pointlight_radiance / float(N);
    }
  }

  if (rt_emissive_instance_indices.num_emissive_instances > 0) {
    const uint N = 4;
    for (uint i = 0u; i < N; i++) {

      EmissivePointReservoir reservoir = UpdateEmissivePointReservoir(ro, v, f0, normal, rma.r, rma.g, albedo, biased_pos, i);
      if (reservoir.emissive_object_instance_idx == INVALID_RESERVOIR_IDX) 
        continue;

      float point_dist = length(reservoir.point - biased_pos);
      reservoir.radiance *= ShadowTest(biased_pos, (reservoir.point - biased_pos) / point_dist, point_dist - 0.001);

      float p_hat = length(reservoir.radiance);
      reservoir.radiance *= p_hat > 0.0 ? reservoir.w_sum / p_hat / float(LIGHT_RIS_ITERS) : 0.0;
      light += reservoir.radiance / float(N);
    }
  }


  vec3 colour_sum = light;
  colour_sum += BounceDiffuse(biased_pos, normal, r, albedo, rma.r);

  imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(colour_sum, 1.0));
}