#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

struct RayPayload {
  vec3 colour;
  vec3 normal;
  float distance;
  float roughness;
  uint mat_flags;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

struct ShadowRayPayload {
  bool hit;
};

layout(location = 1) rayPayloadEXT ShadowRayPayload shadow_payload;

layout(set = 1, binding = 0) uniform accelerationStructureEXT as;

layout(set = 1, binding = 1, rgba8) uniform writeonly image2D img_output;

layout(set = 1, binding = 9) uniform sampler2D sampler_gbuffer_albedo;
layout(set = 1, binding = 10) uniform sampler2D sampler_gbuffer_normals;
layout(set = 1, binding = 11) uniform sampler2D sampler_gbuffer_depth;
layout(set = 1, binding = 12) uniform sampler2D sampler_gbuffer_rma;
layout(set = 1, binding = 13) uniform usampler2D sampler_gbuffer_mat_flags;
layout(set = 1, binding = 16, rgba16) uniform image2D img_reservoirs;

#define LIGHT_BUFFER_DESCRIPTOR_SET_BINDING_OVERRIDE
#define LIGHT_BUFFER_DESCRIPTOR_SET_IDX 1
#define LIGHT_BUFFER_DESCRIPTOR_BINDING 8
#include "LightBuffers.glsl"

#define TRANSFORM_BUFFER_DESCRIPTOR_SET_IDX 1
#define TRANSFORM_BUFFER_DESCRIPTOR_BINDING 14
#include "Transforms.glsl"

#include "CommonUBO.glsl"
#include "Util.glsl"

#define TEX_MAT_DESCRIPTOR_SET_IDX 2
#include "TexMatBuffers.glsl"

#define LIGHT_RIS_ITERS 32u
#define INVALID_RESERVOIR_IDX ~0u

struct Reservoir {
  float w_sum;
  uint current_light_idx;
};

float ShadowTest(vec3 ro, vec3 rd, float max_dist) {
  // Set initially to true, miss shader sets to false
  shadow_payload.hit = true;

  uint flags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
  traceRayEXT(
    as,
    flags,
    0xff,
    0,
    0,
    1,
    ro,
    0.001,
    rd, 
    max_dist,
    1
  );

  return 1.0 - float(shadow_payload.hit);
}

Reservoir UpdateReservoir(vec3 v, vec3 f0, vec3 world_pos, vec3 n, float roughness, float metallic, vec3 albedo, vec3 biased_pos, uint N) {
  const ivec2 coord = ivec2(gl_LaunchIDEXT.xy);
  Reservoir reservoir;
  reservoir.current_light_idx = INVALID_RESERVOIR_IDX;
  reservoir.w_sum = 0.0;

  for (uint i = 0u; i < LIGHT_RIS_ITERS; i++) {
    const uint rnd_idx = uint(gold_noise(vec2(coord), fract(common_ubo.delta_time+sin(N*937.281739)) + i / float(LIGHT_RIS_ITERS)) * float(ssbo_light_data.num_pointlights));
    float weight = length(CalcPointlight(ssbo_light_data.pointlights[rnd_idx], v, f0, world_pos, n, roughness, metallic, albedo));
    weight = weight / (1.0 / float(ssbo_light_data.num_pointlights));

    reservoir.w_sum += weight;

    const float rnd = gold_noise(vec2(coord.yx), fract(common_ubo.delta_time*0.1+sin(N*383.48273)) - i / float(LIGHT_RIS_ITERS));
    if (rnd < weight / reservoir.w_sum) {
      reservoir.current_light_idx = rnd_idx;
    }
  }

  //imageStore(img_reservoirs, coord, vec4(reservoir.w_sum, reservoir.current_weight, uintBitsToFloat(reservoir.current_light_idx), 1.0));

  return reservoir;
}

void CreateCoordinateSystem(in vec3 n, out vec3 nt, out vec3 nb) {
  if (abs(n.x) > abs(n.y))
    nt = vec3(n.z, 0, -n.x) / length(n.xz);
  else
    nt = vec3(0, -n.z, n.y) / length(n.yz);

    nb = cross(n, nt);
}

vec3 UniformSampleHemisphere(float r1, float r2) {
  float sin_theta = sqrt(1 - r1 * r1);
  float phi = 2 * PI * r2;
  return vec3(sin_theta * cos(phi), r1, sin_theta * sin(phi));
}


vec3 BounceDiffuse(vec3 ro, vec3 normal, vec3 reflected_dir, vec3 albedo, float roughness) {
  return vec3(0);
  vec3 colour_sum = vec3(0);

  vec3 nt;
  vec3 nb;
  CreateCoordinateSystem(normal, nt, nb);

  vec3 nt_inner;
  vec3 nb_inner;
  vec3 n_inner;

  float l2_ro = dot(ro, ro);

  float seed = fract(l2_ro+ro.x+ro.y+ro.z+common_ubo.time_elapsed+common_ubo.delta_time);
  vec2 xy = gl_LaunchIDEXT.xy;
  xy += fract(vec2(sin(xy.x*1038.283726 + xy.y*common_ubo.delta_time), cos(xy.x*common_ubo.time_elapsed+xy.y*9278.33337)));
  for (uint ray_idx = 0; ray_idx < 8; ray_idx++) {
    seed = fract(seed + ray_idx/8.0);
    vec3 rnd = UniformSampleHemisphere(gold_noise(xy, fract(seed+ray_idx/8.0)), gold_noise(xy, fract(seed+ray_idx/8.0)+0.1));
    vec3 rd = vec3(
      rnd.x * nb.x + rnd.y * normal.x + rnd.z * nt.x,
      rnd.x * nb.y + rnd.y * normal.y + rnd.z * nt.y,
      rnd.x * nb.z + rnd.y * normal.z + rnd.z * nt.z
    );

    traceRayEXT(
      as,
      gl_RayFlagsOpaqueEXT,
      0xff,
      0,
      0,
      0,
      ro,
      0.01,
      rd, 
      1000,
      0
    );

    colour_sum += albedo * payload.colour * max(cos(dot(rd, normal)), 0.0) / 8.0;
    if (payload.distance < 0.f || bool(payload.mat_flags & MAT_FLAG_EMISSIVE)) {
      continue;
    }

    vec3 new_pos = ro + rd * payload.distance;
    n_inner = payload.normal;
    CreateCoordinateSystem(n_inner, nt_inner, nb_inner);

    for (uint bounce_idx = 0; bounce_idx < 2; bounce_idx++) {
      rd = UniformSampleHemisphere(gold_noise(xy, fract(seed+bounce_idx*0.5+0.2)), gold_noise(xy, fract(seed+bounce_idx*0.5+0.3)));
      rd = vec3(
      rd.x * nb_inner.x + rd.y * n_inner.x + rd.z * nt_inner.x,
      rd.x * nb_inner.y + rd.y * n_inner.y + rd.z * nt_inner.y,
      rd.x * nb_inner.z + rd.y * n_inner.z + rd.z * nt_inner.z
      );

      traceRayEXT(
        as,
        gl_RayFlagsOpaqueEXT,
        0xff,
        0,
        0,
        0,
        new_pos,
        0.01,
        rd, 
        1000,
        0
      );
      colour_sum += albedo * payload.colour * 0.25 * max(cos(dot(rd, n_inner)), 0.0) / 8.0;
    }
  }

  return colour_sum * (2 * PI);
}


void main() {
  vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);

  vec3 albedo = texelFetch(sampler_gbuffer_albedo, ivec2(gl_LaunchIDEXT), 0).rgb;

  const vec3 rma = texelFetch(sampler_gbuffer_rma, ivec2(gl_LaunchIDEXT), 0).rgb;
  const uint mat_flags = texelFetch(sampler_gbuffer_mat_flags, ivec2(gl_LaunchIDEXT), 0).r;


  if (bool(mat_flags & MAT_FLAG_EMISSIVE)) {
    imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(albedo, 1.0));
    return;
  } 

  vec3 normal = texelFetch(sampler_gbuffer_normals, ivec2(gl_LaunchIDEXT), 0).rgb;
  vec3 ro = WorldPosFromDepth(texelFetch(sampler_gbuffer_depth, ivec2(gl_LaunchIDEXT), 0).r, uv);

  vec3 v = normalize(common_ubo.cam_pos.xyz - ro);
	vec3 r = reflect(-v, normal);
	float n_dot_v = max(dot(normal, v), 0.0);

  vec3 f0 = vec3(0.04); // TODO: Support different values for more metallic objects
  f0 = mix(f0, albedo, rma.g);

  vec3 biased_pos = ro + normal * 0.1;

  vec3 light = CalcDirectionalLight(v, f0, normal, rma.r, rma.g, albedo) * ShadowTest(biased_pos, ssbo_light_data.dir_light.dir.xyz, 1000);

  if (ssbo_light_data.num_pointlights > 0) {
    const uint N = 16;
    for (uint i = 0u; i < N; i++) {
      Reservoir reservoir = UpdateReservoir(v, f0, ro, normal, rma.r, rma.g, albedo, biased_pos, N);
      if (reservoir.current_light_idx != INVALID_RESERVOIR_IDX) {
        float light_dist = length(ssbo_light_data.pointlights[reservoir.current_light_idx].pos.xyz - biased_pos);
        vec3 pointlight_radiance = CalcPointlight(ssbo_light_data.pointlights[reservoir.current_light_idx], v, f0, ro, normal, rma.r, rma.g, albedo.rgb) * 
          ShadowTest(biased_pos, (ssbo_light_data.pointlights[reservoir.current_light_idx].pos.xyz - biased_pos) / light_dist, light_dist);

        float p_hat = length(pointlight_radiance);

        pointlight_radiance *= p_hat > 0.0 ? (1.0 / p_hat) * reservoir.w_sum / float(LIGHT_RIS_ITERS) : 0.0;
        light += pointlight_radiance / 8.0;
      }
    }
  }


  vec3 colour_sum = light;
  colour_sum += BounceDiffuse(biased_pos, normal, r, albedo, rma.r);

  imageStore(img_output, ivec2(gl_LaunchIDEXT), vec4(colour_sum, 1.0));
}