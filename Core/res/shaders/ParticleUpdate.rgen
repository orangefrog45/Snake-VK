#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable

struct RayPayload {
    vec3 contact_normal;
    vec3 contact_velocity;
    vec3 contact_position;
    float distance;
};

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

layout(set = 1, binding = 0) uniform accelerationStructureEXT as;

#include "CommonUBO.glsl"
#include "Util.glsl"
#include "Particle.glsl"

layout(set = 1, binding = 1) buffer ParticleBuf { Particle ptcls[]; } ptcl_buf;

void TraceCollisionRay(vec3 dir, float len, inout float current_highest_speed_weight, inout RayPayload candidate_payload) {
    traceRayEXT(
    as,
    gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
    0xff,
    0,
    0,
    0,
    ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.xyz - dir * ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.w, // Trace from "back" of particle
    0.0,
    dir, 
    len,
    0
    );

    vec3 relative_velocity = ray_payload.contact_velocity - ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz;

    // Use speed weighting as the highest speed object is what the collision should occur with for more realistic results
    float speed_weight = length(relative_velocity);
    
    if (ray_payload.distance > 0 && speed_weight > current_highest_speed_weight) {
        current_highest_speed_weight = speed_weight;
        candidate_payload = ray_payload;
    }
}

void main() {
    const float dt = 1.0 / 20.0;

    ray_payload.distance = -1.f;
    ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.y -= 9.8 * dt;

    float speed = length(ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz);
    vec3 velocity_dir = ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz / speed;
    vec3 velocity_right = abs(dot(velocity_dir, vec3(0, 1, 0))) > 0.99 ? cross(velocity_dir, vec3(0, 0, 1)) : cross(velocity_dir, vec3(0, 1, 0));
    vec3 velocity_up = cross(velocity_right, velocity_dir);

    RayPayload candidate_payload;
    candidate_payload.distance = -1.0;
    float current_highest_speed_weight = 0.0;

    // Trace multiple collision rays in different directions to increase chance of intersection with overlapping geometry
    TraceCollisionRay(velocity_dir, speed * dt + ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.w * 2.0, current_highest_speed_weight, candidate_payload);
    TraceCollisionRay(velocity_right, ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.w * 2.0, current_highest_speed_weight, candidate_payload);
    TraceCollisionRay(velocity_up, ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.w * 2.0, current_highest_speed_weight, candidate_payload);
    
    if (candidate_payload.distance > 0.f) { // Collision detected
        const float restitution = 0.5;
        
        vec3 relative_velocity = ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz - candidate_payload.contact_velocity;
        ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.xyz = candidate_payload.contact_position + candidate_payload.contact_normal * (ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.w + 0.01);
        ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz = reflect(relative_velocity, candidate_payload.contact_normal) * restitution;
    }

    ptcl_buf.ptcls[gl_LaunchIDEXT.x].position_radius.xyz += ptcl_buf.ptcls[gl_LaunchIDEXT.x].velocity.xyz * dt;
}
